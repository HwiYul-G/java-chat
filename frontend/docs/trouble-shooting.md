[문제 상황]
a가 b와 개인 채팅방1 에서 대화를 하다가 그룹 채팅방1에서 대화를 한다.
a가 b와 대화하던 개인 채팅방으로 돌아가서 메시지를 보내면 메시지는 서버로 보내지지만 자신의 화면에 보이지 않는다. (현재 화면을 벗어나면서 구독이 취소된다?)


[고민과 해결]

웹소켓은 서버와 클라이언트 사이의 양방향 커뮤니케이션으로 정의된다. 즉 웹 소켓으로 동시에 데이터를 커뮤니케이트하고 교환할 수 있다는 것을 의미한다. 이 프로토콜(웹 소켓)은 처음부터 full duplex 방식을 정의한다.
웹소켓은 데스크톱의 풍부한 기능들을 웹 브라우저로 가져왔다. 웹소켓은 클라이언트 서버 웹 기술에서 긴 시간 기다렸던 것의 진화를 보여준다.

청중
이 튜토리얼은 HTTP의 이해와 프로토콜의 기본 지식이 있는 누군가를 위해 준비되었다. 이 튜토리얼을 완성한 후에, 웹 소켓을 만드는 것이 전통적인 HTTP request response pattern와 다른 것을 이해하는 것에서 중급 정도의 지식을 가지게 된다.

전제 조건
이 튜토리얼을 시작하기 전에, http protocl의 이해와 js의 기본기가 있어야 한다.
만약 이 개념들을 잘 모르면 js와 http의 짧은 튜토리얼을 경험하고 오라

소개
글자그대로의 용어에서, 핸드쉐이크는 2개의 개인들이 오른 손을 잡고 흔드는 것을 의미할 수 있다. 
이는 인사, 축하, 동의나 작별을 상징화하는 것일 수 있다. 
컴퓨터 사이언스에서 핸드쉐이크는 서버가 클라이언트와 동기 안에 있는 것을 보장하는 과정이다.
핸드쉐이크는 웹 소켓 프로토콜의 기본 개념이다.

웹 소켓 - 정의
웹 소켓은 서버와 클라어인트 사이의 양방향 커뮤니케이션으로 동시에 데이터를 교환하고 주고 받게 한다.
웹 소켓의 핵심 포인트는 true oncurrency와 성능의 최적화이다. 이는 더 반응적이고 풍부한 웹 앱을 만든다.

웹 소켓 프로토콜의 묘사
이 프로토콜은 처음부터 full duplex를 저으이한다. 웹 소켓은 웹 브라우저로 컴퓨터의 풍부한 기능을 가져왔다.
이것은 클라이언트 서버 웹 기술에서 긴 시간 기다렸던 것의 진화이다.

웹 소켓의 주요 특징은 다음과 같다.
- 웹 소켓 프로토콜은 표준화되어져있다. 즉 웹 서버와 클라이언트는 웹 소켓 프로토콜의 도움으로 실시간 커뮤니케이션이 가능하다.
- 웹 소켓은 클라이언트와 서버 사이의 실시간 커뮤니케이션을 위한 cross platform standard로 변환되었다.
- 이 표준은 애플리케이션의 새로운 종류를 가능하게한다. 실시간 웹 앱에 대한 비즈니스는 기술의 도움으로 빨라졌다.
- 웹 소켓의 가장큰 장점은 하나의 tcp 연결 위에서 full duplex를 제공하는 것이다.

url
http는 http와 https같은 스키마의 하나의 집합을 가진다.
웹 소켓 프로토콜은 URL 패턴 안에서 정의된 유사한 스키마를 가진다.
ws://exaple.com:8000/chat.php
schema://host:port/server

브라우저 지원
웹 소켓 프로토콜의 가장 최신의 명세는 RFC 6455로 정의된다. 이는 제안된 표준이다.
RFC 6455는 다양한 브라우저에서 지원된다.

웹 소켓의 필요로 뛰어들기 전에 기존의 기술을들 볼 필요가 있다.
이 기존의 기술들은 duplex communication을 위한 것이다.
- polling
- long polling
- streaming
- postback and ajax
- html5

Polling
폴링은 메소드로 정의된다. 이는 전송에서 존재하는 데이터와 무관히 주기적인 요청을 수행한다.
이 주기적인 요청은 동기적인 방식으로 보내진다. 
클라이언트는 서버에게 특정한 시간 간격으로 정기적인 요청을 보낸다.
서버의 응답은 이용가능한 데이터나 워닝 메시지를 보낸다.

long polling
이름에서 보이는 것처럼 long polling은 polling과 유사한 기술을 포함한다.
클라이어늩와 서버는 데이터가 패치되거나 타임아웃이 발생할 때까지 연결을 윶한다.
연결이 어떤 이유로 없어지면, 클라이언트는 재시작하고 연속적인 요청을 보낸다.
long polling은 polling process의 수행 개선이다. 하지만 지속적인 요청은 그 과정을 느리게 할 수 있다.

streaming
스트리밍은 실시간 데이터 전송에 최적의 선택으로 여겨진다.
ㅅ버ㅡㄴ 연결을 열고 활성화 시킨다. 필요한 데이터가 패치되거나 그렇지 않을 때까지
이 경우에 연결은 무한히 open되어 있다.
스트리밍은 파일 사이즈, 증가하는 딜레이를 가진 http heaers를 포함한다.
이것은 주요한 결함으로 여겨진다.

ajax
ajax는 js의 xmlhttprequest object에 기반을 둔다. ajax는 비동기 js와 xml 의 약식 형태이다.
xmlhttp request object는 완전한 웹 페이지를 리로딩하지 않고 js의 실행을 허락한다.
ajax는 웹 페이지의 부분을 보내고 받는다.

ajax의 코드 스닙펫은 xmlhttp object륵 가진다.

html5
html5는 웹 앱을 개발하고 디자인하기 위한 활발한 프레임워크이다.
그 주요한 기둑은 markup, css, js apis가 함게 사용된다.

왜 우리는 웹 소켓을 필요로 하는가?
인터넷은 개념적인 정보 웹을 구성하는 다른 페이지를 연결하는 html pages의 집합으로 생각된다.
이 시간동안에, 정적인 자원은 증가한다. 예를 들어서 이미지, 웹 페브릭 같은 부분으로

서ㅓ 기술은 도엊ㄱ인 서버 페이지를 허락하도록 진화했다.
그 동적인 페이지들의 내용은 쿼리 기반으로 생성된다.

곧 동적인 페이지들의 필요는 동적인 hypertext markup lang의 이용가능성으로 이끌어진다.
js 덕분이다. 수년에 걸쳐서 우리는 http polling이 따르는 페이지 reload를 피하기 위한 시도

그러나 그러한 해결책들중 어떤 거것도 진정으로 cross browser 해결책이 되진 않았다.
이것은 웹 소켓 프로토콜의 필요를 보여주었고, 이것은 full duplex 가 웹 브라우저로 데스크톱 풍부한 기능을 가져왔따.

websocket - functionalities
웹 소켓은 웹 커뮤니케션 역사에서 주요한 업그레이드를 보여준다.
웹 소켓의 등장 전에 클라이언트와 서버의 모든 커뮤니케이션은 HTTP에 기반을 두었다.

웹 소켓은 지속적인 full dupelx인 커넥션의 동적인 흐름에서 도움이 되었다.
웹 소켓은 기존의 프로토콜의 모든 결함을 극복하는 효율성 때문에 게임 체인져가 되었다.

개발자와 아키텍쳐를 위한 웹 소켓
- 웹 소켓은 tcp에 기반을 둔 프로토콜이다. 그러나 웹 소켓은 다른 프로토콜을 지원하도록 디자인되었다. 즉 전통적으로 순수한 tcp connection 위에 의존해서 실행된다.
- 웹 소켓은 다른 프로토콜을 실행할 수 있는 전송 층 위에 있다. 웹 소켓 API는 하위 프로토콜들을 정의하는 능력을 지지한다.:특정한 프로토콜을 해석할 수 있는 프르토콜 라이브러리들
- XMPP, STOMP, AMQP를 포함한 프로토콜의 예시. 개발자들은 더이상 HTTP request response paradigm의 용어 속에서 생각할 필요가 없다.
- 브라우저 측에서의 유일한 필요는 js 라이브러리를 실행시키는 것이다. 그 js 라이브러리는 웹 소켓 핸드쉐이크를 해석하고 설립하고 웹 소켓 연결을 유지하는 것이다.
- 서버 측에서는 산업 표준은 기존의 프르토콜 라이브러리를 실행시키는 것이다. 그 기존의 프로토콜 라이브러리는 tcp 위에서 실행되고 웹 소켓 게이트웨이를 활용한다.

웹 소켓 커넥션은 HTTP를 통해서 초기화 된다. HTTP 서버는 전통적으로 web socket handshakes를 업그레이드 요청으로 해석한다.
웹 소켓은 기존 http 환경에 보완적인 add-on이 될 수 있고 웹 기능을 추가하는 필요한 산업을 제공할 수 있다.
웹 소켓은 더 진보적인 full duplex 프로톸ㄹ이다.

functions of websockets
웹 소켓의 커넥션을 설립하는 단계
- 클라이언트는 웹 소켓 핸드쉐이크로 알려진 과정을 통해서 connection을 설립한다.
- 그 과정은 클라이언트가 서버로 정기적인 http 요청을 보냄으로 시작한다.
- 업그레이드 헤더가 요청된다. 이 요청에서, 웹 소켓 커넥션을 위한 요청을 서버에게 알린다.
- 웹 소켓 URLs은 ws 스키마를 사용한다. 웹 소켓 URLs는 HTTPs와 같은 것으로 사용할 수도 있다.
예시
```
GET ws://websocket.host.com/ HTTP/1.1
Origin: http://host.com
Connection: Upgrade
Host: websocket.host.com
Upgrade: websocket
```
웹 소켓은 웹과 모바일 산업에서 핵심적인 역할을 한다. 웹 소켓의 중요성은 아래에 있다.
- 웹 소켓은 웹과 관련되어 있다. 웹은 브라우저에 대한 기술들의 집합으로 구성되어 있다.
    즉 데스크탑, 랩톱 테블릿 스마트폰을 포함한 다양한 디바이스를 위한 넓은 커뮤니케이션 플렛폼이다.
- 웹소켓을 활용하는 HTML 5 앱은 웹 브라우저를 가능하게 하는 HTML5
- 웹 소켓은 full duplex이다. 웹 소켓의 접근은 채팅룸과 가튼 웹앱의 특정 분야에서 잘 일한다.

[WebSocket Roles]
Events and Actions
서버와 클라이언트가 통신하려면 connection을 초기화하는 것은 필수적이다.
connection 초기화를 위해서 원격 혹은 지역 서버를 가진 URL을 가진 js object의 생성이 필요하다.
`var socket = new WebSocket("ws://echo.websocket.org");`
위에 언급된 URL은 테스트를 할 수 있는 공개된 주소이다.
위 서버는 항상 열려있고 메시지를 받았을 때 받은 메시지를 클라이언트에게 그대로 도렬준다.

이것은 애플리케이션이 올바르게 작동하는 것을 보장하는 가장 중요한 단계이다.

Events: open, message, close, error
각 이벤트들은 onopen, onmessage, onclose, onerror같은 함수를 구현함으로 다룰 수 있다.
각 이벤트들은 addEventListener 메소드의 도움으로 구현할 수 있다.

Open
클라이언트와 서버 사이의 connection이 한 번 되면, open event는 웹 소켓 인스턴스로부터 촉발된다.
이것은 최초의 핸드세이크이다. connection이 성립되서 발생하는 이벤트를 onopen이라 한다.


Message
Close
Error

---
리엑트 애플리케이션 안애서 실시간 커뮤니케이션의 도메인에서, 공통의 문제는 웹 소켓 구현을 다룰 때 등장한다.
실시간 업데이트를 추구하는 각 컴포넌트에 대한 독립된 연결을 셋팅하는 것의 생각은 유혹적이지만, 이 라우트는 빠르게 활성화된 연결의 convoluted network로 이끈다.

모든 잠재적인 컴포넌트 리스너에 대한 여러개의 지속되는 연결들을 다루는 것은 불필요한 네트워크 로드를 유도하고, 애플리케이션이 확작됨에 따라 스케일가능성과 수행을 제한한다. 
게다가, 모든 컴포넌트들에 메시지를 무차별적으로 디스패칭하는 것은 예상하지 못한 업데이트를 유발하고 사용자 경험을 망칠 것이다.

이 문제는 효율적으로 다루는 것은 다면적인 전략을 필요로한다.
하나의 생각가득한 접근법은 웹소켓 관리를 중앙집권화하는 것을 포함한다.
이 중앙집권화 방식은 동적으로 특정한 메시지 채널을 구독하는 것이다.
이것은 열린 커넥션의 수를 줄이고 메시지가 오직 메시지를 필요로하는 컴포넌트로 라우트되는 것을 보장되게 한다.
그리고 불필요한 업데이트를 저장하게 하고 더 스트림라인되고 반응적이고 자원 효율적인 실시간 경험을 가능하게 한다.

이 아티클은 WSContext pattern의 힘을 깊게 탐구할 것이고 WSContext pattern의 복잡성을 다루는 것을 탐구하고, 네가 반응적이고 실시간 react applications을 빌드하게 한다.

패턴
WebSocketContext 패턴은 약간의 원칙에 기반을 두어서 동작한다.
WebSocketContext는 WebSocketProvider같은 핵심적인 컴포넌트드를 포괄하고 메시지 전달을 재단하기 위해서 동적인 subscriptions을 이용한다.

핵심원칙
- Single Connection Centralized WS service
    너의 앱의 다른 부분을 위해서 여러 웹 소켓 커넥션을 실행하는 것 대신에, 이 패턴은 '하나의 connection'을 사용하는 것을 홍보한다. 초기화, 메시지 핸들링, 콜백 등록을 포함한 모든 커뮤니케이션 로직은 하나의 컴포넌트나 context 안에서 중앙집권화되어 있다. 이 중앙집권방식은 커뮤니케이션 시스템은 지속적이고 조직화되고 관리하기 쉽다.
- Integration with Global State Management
    context는 중앙집권화된 방식으로 네가 connection과 관련된 state를 관리할 수 있게 허락한다.
    웹소켓 인스턴스나 연결 세부사항을 깊게 보는 것 대신에, 너는 context provider안에서 로직을 캡슐화할 수 있다. 이것은 더 깨끗하고 조직화된 조직 구조를 홍보한다.
- Subscription Mechanism
    context를 사용함으로써, 너는 웹소켓 관리의 세부사항으로부터 컴포넌트를 약한 결합을 만들 수 있다.
    컴포넌트들은 초기화와 메시지 핸들링의 복잡한 세부사항을 이해할 필요가 없이 subscribe와 unsubscribe 함수를 사용하는 것에 초점화된다.
- Messages Handling with Multiple Components
    context를 사용함으로써, 중앙집권화된 callback registry는 channels object 안으로 유지될 수 있다.
    이 object는 그들의 각자의 callback functions에 다른 channels를 매핑시킨다.
    각 callback은 컴포넌트의 특정한 타입의 메시지를 처리하는 능력을 나타내거나 특정한 chat channel로부터..
    이러한 접근방법은 네가 복잡한 커뮤니케이션 로직을 여러 컴포넌트들 사이의..
    예를 들어서, 다른 채널으 리스닝하는 다른 컴퓨넌트를 가질 수 있으면 그것은 다양한 메시지 종류에 반응하고 심지어 특정한 채팅 채널이 이용가능하지 않을 때 fallback 행동을 구현한다. 왜냐하면 컴포넌트들은 렌더링되지 않으므로?

핵심적인 컴포넌트들: WebSocket Context, WebSocket Provider, WebSocket Message Consumers
1. WebSocket Context
    웹소켓 커뮤니케이션 로직을 관리하는 데 사용되는 react context
    websocket context는 subscribe와 unsubscribe functions을 WSProvider 컴포넌트의 노출시키는 방법을 제공한다. 
2. WebSocket Provider
    리엑트 컴포넌트는 커뮤니케이션 로직을 가진 자식을 덮고 웹소켓과 관련된 함수를 context를 통해 노출시킨다.
    이 컴포넌트는 single connection centralized websocket service 개념을 캡슐화 한다.
3. WebSocket Messages Consumers
    웹소켓 메시지 컨슈머는 메시지 소비와 렌더링에 책임이 있는 UI 컴포넌틍다.
    이 컴포넌트들은 subscribe와 unsubscribe 함수로 provider와 소통한다.

패턴을 구현하기: 실시간 채팅 애플리케이션
여러 사용자가 여러 채팅 방에 참여하는 실시간 채팅 애플리케이션을 생각해봐라.
실시간 커뮤니케이션을 쉽게하고, 모든 채팅에 하나의 연결을 설립하는 것은 효율적이다.
그러나, 2개의 구별된 사용 케이스를 수용하는 것은 복잡한 레이어를 추가한다.

새로운 메시지가 웹 소켓 서버에서 왔을 때 애플리케이션은 적절한 행동을 보여주길 결정해야한다.
우선 그 앱은 메시지가 속하는 채팅방이 맞는지 검증하고 현재 사요자 인터페이스에서 랜더링하거나 보여줘야한다.
이러한 검증(메시지가 속하는 채팅방이 맞느지)은 2가지 가능한 시나리오가 있다.
1. Chat is Rendered
    채팅방이 현재 랜더링되었으면(들어온 채팅의 식별자가 렌더링된 채티으이 식별자와 일치하면)
    그 메시지ㅡㄴ 즉시 특정한 사용자의 인터페이스로 보내진다.
    이것은 메시지가 부드럽게 나타나는 것을 보장한다.
2. Chat is not rendered
    채팅 방이 현재 랜더링되지 않은 경우(들어온 메시지의 식별자가 랜더링된 채팅과 매치하는 것이 없는 경우)
    ㅁ시지는 일반적인 notification 메커니즘으로 라우팅된다.
    이 메커니즘은 사용자에게 새로운 메시지를 알리는 notification을 보여줄 수 있다.
    비록 그들이 응답하는 채팅방에 참여중이 아니더라도

기술적인 필요사항: 메시지 보여주기 전략, 컴포넌트 시각화 로직, 리던덴시 최소화
- 웹소켓 커넥션은 지능적으로 실시간 알림으로 메시지를 전달하는 것과 구분된다.
- 웹소켓 관리는 채팅 컴포넌트의 시각적 status를 인지해야만한다. 컴포넌트가 보여지지 않을 때 들어온 메시지들은 notifications로 처리되어야 한다.
- notifications과 채팅 둘다 최적의 사용자 경험보다 더 적은 reduendayc





참고자료
https://yunae.tistory.com/entry/React-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EC%B1%84%ED%8C%85-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0-STOMP

https://blog.stackademic.com/websockets-and-react-wscontext-and-components-subscription-pattern-4e580fc67bb5
